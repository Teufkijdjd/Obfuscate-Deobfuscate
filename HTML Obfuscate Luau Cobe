<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ROBLOX ABSOLUTE OBF</title>
<style>
body{background:#030303;color:#ff1b1b;font-family:monospace}
textarea{width:100%;height:240px;background:#000;color:#f00;border:1px solid #222;padding:8px}
button{background:#111;color:#0ff;border:1px solid #333;padding:10px;margin:6px}
</style>
</head>
<body>
<h2>☠️ ROBLOX LUAU — ABSOLUTE OBFUSCATION</h2>
<textarea id="in" placeholder="Clean Luau"></textarea>
<button onclick="obf()">☠️ ABSOLUTE OBF</button>
<textarea id="out"></textarea>

<script>
const R=(a,b)=>Math.floor(Math.random()*(b-a)+a);
const RN=()=>"_"+Math.random().toString(36).slice(2,9);

// rotate helpers
const rol=(v,r)=>((v<<r)|(v>>(8-r)))&255;
const ror=(v,r)=>((v>>r)|(v<<(8-r)))&255;

// encrypt per-string with time-noise seed
function enc(s){
 let k=R(30,240), r=R(1,7), n=R(3,17), d=[];
 for(let i=0;i<s.length;i++){
  let c=s.charCodeAt(i);
  c=rol((c^k)+n,r);
  d.push((c+R(1,9))&255);
 }
 return {k,r,n,d};
}

function obf(){
 let src=document.getElementById("in").value;
 let pool=[];
 src=src.replace(/"(.*?)"/g,(m,s)=>{
  let e=enc(s); let i=pool.length; pool.push(e);
  return `__S(${i})`;
 });

 let P=RN(), D=RN(), VM=RN(), T=RN();

 // pool
 let poolCode=`local ${P}={`;
 pool.forEach(e=>{
  poolCode+=`{${e.k},${e.r},${e.n},{${e.d.join(",")}}},`;
 });
 poolCode+=`}\n`;

 // time-based one-shot decrypt
 let dec=`
local ${T}=os.clock()
local function ${D}(i)
 local t=${P}[i+1]; if not t then return "" end
 local k,r,n,d=t[1],t[2],t[3],t[4]
 local s=""; local tk=math.floor(${T}*1000)%255
 for j=1,#d do
  local c=(d[j]-((j+tk)%7))&255
  c=ror(c,r)
  c=((c-n)&255)~k
  s=s..string.char(c)
 end
 ${P}[i+1]=nil -- ONE-SHOT
 return s
end
`;

 src=src.replace(/__S\((\d+)\)/g,`${D}($1)`);

 // fake VM swarm
 let fakeVM=`
do
 for _=1,${R(4,8)} do
  (function()
   local x=0; for i=1,${R(40,90)} do x=(x+i*3)%${R(11,29)} end
  end)()
 end
end
`;

 // anti-tamper checksum
 let chk=`
do
 local c=0; for i=1,64 do c=(c+i)%19 end
 if c~=8 then while true do end end
end
`;

 // real VM wrapper (opcode shuffle illusion)
 let vm=`
local function ${VM}()
 local pc=1
 local code={
  function() ${src} end,
  function() return end,
 }
 while code[pc] do
  local ok=pcall(code[pc]); if not ok then break end
  pc=pc+1
 end
end
`;

 let out=`-- ☠️ ABSOLUTE ROBLOX OBF
${fakeVM}
${chk}
${poolCode}
${dec}
${vm}
${VM}()
`;

 document.getElementById("out").value=out;
}
</script>
</body>
</html>    }
    button {
      background: #6366f1;
      border: none;
      color: white;
      padding: 10px 20px;
      cursor: pointer;
      font-weight: bold;
      margin-right: 10px;
    }
    button:hover {
      background: #4f46e5;
    }
    pre {
      background: #111827;
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
      white-space: pre-wrap;
    }
    .section {
      margin: 30px 0;
    }
    .label {
      font-weight: bold;
      color: #93c5fd;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>VM Lua Obfuscator (Web Edition)</h1>
    
    <div class="section">
      <p class="label">Enter Lua instructions (simple format)</p>
      <p>Supported instructions right now:</p>
      <ul>
        <li>push_int 123</li>
        <li>push_str "hello"</li>
        <li>add / sub / mul</li>
        <li>print</li>
        <li>halt</li>
      </ul>
      <textarea id="inputInstructions" placeholder="Enter instructions one per line... e.g.:
push_int 777
push_int 333
add
print
halt"></textarea>
    </div>

    <div class="section">
      <button onclick="obfuscate()">Obfuscate Now!</button>
      <button onclick="document.getElementById('output').textContent = ''">Clear Result</button>
    </div>

    <div class="section">
      <p class="label">Obfuscated Lua VM Code (copy & paste ready)</p>
      <pre id="output">Click Obfuscate to start...</pre>
    </div>

    <div class="section">
      <p class="label">Debug Info</p>
      <pre id="debugInfo"></pre>
    </div>
  </div>

  <script>
    // ==================== Generate random opcodes every time ====================
    function generateRandomOpcodes() {
      const names = ['PUSH_INT', 'PUSH_STR', 'ADD', 'SUB', 'MUL', 'PRINT', 'POP', 'HALT'];
      const used = new Set();
      const mapping = {};

      names.forEach(name => {
        let val;
        do {
          val = Math.floor(Math.random() * 206) + 50; // 50-255
        } while (used.has(val));
        used.add(val);
        mapping[name] = val;
      });

      return mapping;
    }

    // ==================== Generate bytecode from instructions ====================
    function generateBytecode(instructions, opcodes) {
      const bytecode = [];
      const stringPool = [];
      const stringIndices = {};

      instructions.forEach(line => {
        line = line.trim();
        if (!line) return;

        // Insert random junk instruction
        if (Math.random() < 0.35) {
          bytecode.push(Math.floor(Math.random() * 256));
        }

        const parts = line.split(/\s+/);
        const cmd = parts[0].toLowerCase();

        if (cmd === 'push_int') {
          const num = parseInt(parts[1]);
          bytecode.push(opcodes['PUSH_INT']);
          bytecode.push(num & 0xFF);
          bytecode.push((num >> 8) & 0xFF);
        } 
        else if (cmd === 'push_str') {
          const str = parts.slice(1).join(' ').replace(/^["']|["']$/g, '');
          if (!(str in stringIndices)) {
            stringIndices[str] = stringPool.length;
            stringPool.push(str);
          }
          bytecode.push(opcodes['PUSH_STR']);
          bytecode.push(stringIndices[str]);
        } 
        else if (['add','sub','mul','print','pop','halt'].includes(cmd)) {
          const upper = cmd.toUpperCase();
          if (upper in opcodes) {
            bytecode.push(opcodes[upper]);
          }
        }
      });

      // Always end with HALT
      bytecode.push(opcodes['HALT']);
      return { bytecode, stringPool };
    }

    // ==================== Encrypt bytecode (XOR + random junk) ====================
    const XOR_KEY = Math.floor(Math.random() * 91) + 30; // 30-120

    function encryptBytecode(bc) {
      const encrypted = [];
      bc.forEach(b => {
        encrypted.push(b ^ XOR_KEY);
        if (Math.random() < 0.25) {
          encrypted.push(Math.floor(Math.random() * 256)); // junk byte
        }
      });
      return encrypted;
    }

    // ==================== Generate fake VM sections ====================
    function generateFakeVMs(count = 4) {
      const fakes = [];
      for (let i = 0; i < count; i++) {
        const size = Math.floor(Math.random() * 23) + 8;
        const section = Array(size).fill(0).map(() => Math.floor(Math.random() * 256));
        fakes.push(section);
      }
      return fakes;
    }

    // ==================== Generate final Lua VM code ====================
    function generateLuaVM(opcodes, encrypted, fakes) {
      const opcodesStr = Object.entries(opcodes)
        .map(([k, v]) => `['${k}'] = ${v}`)
        .join(',\n    ');

      const fakeStr = fakes.map(arr => `{${arr.join(',')}}`).join(',\n    ');

      const bytecodeStr = `{${encrypted.join(',')}}`;

      return `-- VM Obfuscated Code
local KEY = ${XOR_KEY}
local OPCODES = {
    ${opcodesStr}
}

local function run(enc)
    local bc = {}
    for i = 1, #enc do
        bc[i] = bit32.bxor(enc[i], KEY)
    end
    
    local stack = {}
    local pc = 1
    
    while pc <= #bc do
        local op = bc[pc]; pc = pc + 1
        
        if op == OPCODES['PUSH_INT'] then
            local lo = bc[pc]; pc = pc + 1
            local hi = bc[pc]; pc = pc + 1
            table.insert(stack, lo + hi * 256)
        elseif op == OPCODES['PRINT'] then
            print(table.remove(stack))
        -- Add other handlers as needed
        elseif op == OPCODES['HALT'] then
            break
        end
        
        -- Anti-analysis: random skip
        if math.random() < 0.12 then
            pc = pc + math.random(1,4)
        end
    end
end

-- Fake sections to confuse reverse engineers
local fakes = {
    ${fakeStr}
}

for _,f in ipairs(fakes) do
    local _ = f[math.random(1, #f)]
end

-- Execute real code
run(${bytecodeStr})
`;
    }

    // ==================== Main obfuscate function ====================
    function obfuscate() {
      const input = document.getElementById('inputInstructions').value;
      const lines = input.split('\n').map(l => l.trim()).filter(Boolean);

      if (lines.length === 0) {
        alert("Please enter some instructions first!");
        return;
      }

      const opcodes = generateRandomOpcodes();
      const { bytecode, stringPool } = generateBytecode(lines, opcodes);
      const encrypted = encryptBytecode(bytecode);
      const fakes = generateFakeVMs();

      const result = generateLuaVM(opcodes, encrypted, fakes);

      document.getElementById('output').textContent = result;

      // Show debug info
      document.getElementById('debugInfo').textContent = 
        `XOR Key: ${XOR_KEY}\n` +
        `String Pool:\n\( {stringPool.map((s,i) => `[ \){i}] "${s}"`).join('\n')}`;
    }
  </script>
</body>
</html>    }
    button {
      background: #6366f1;
      border: none;
      color: white;
      padding: 10px 20px;
      cursor: pointer;
      font-weight: bold;
      margin-right: 10px;
    }
    button:hover {
      background: #4f46e5;
    }
    pre {
      background: #111827;
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
      white-space: pre-wrap;
    }
    .section {
      margin: 30px 0;
    }
    .label {
      font-weight: bold;
      color: #93c5fd;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>VM Lua Obfuscator (Web Edition)</h1>
    
    <div class="section">
      <p class="label">ใส่ instructions ของโค้ด Lua (รูปแบบง่าย ๆ)</p>
      <p>ตัวอย่างที่รองรับตอนนี้:</p>
      <ul>
        <li>push_int 123</li>
        <li>push_str "hello"</li>
        <li>add / sub / mul</li>
        <li>print</li>
        <li>halt</li>
      </ul>
      <textarea id="inputInstructions" placeholder="พิมพ์ instructions ทีละบรรทัด... เช่น:
push_int 777
push_int 333
add
print
halt"></textarea>
    </div>

    <div class="section">
      <button onclick="obfuscate()">Obfuscate Now!</button>
      <button onclick="document.getElementById('output').textContent = ''">เคลียร์ผลลัพธ์</button>
    </div>

    <div class="section">
      <p class="label">ผลลัพธ์ Lua VM Code (copy ไปใช้ได้เลย)</p>
      <pre id="output">กดปุ่ม Obfuscate เพื่อเริ่ม...</pre>
    </div>

    <div class="section">
      <p class="label">ข้อมูลเพิ่มเติม</p>
      <pre id="debugInfo"></pre>
    </div>
  </div>

  <script>
    // ==================== OPCODES สุ่มใหม่ทุกครั้ง ====================
    function generateRandomOpcodes() {
      const names = ['PUSH_INT', 'PUSH_STR', 'ADD', 'SUB', 'MUL', 'PRINT', 'POP', 'HALT'];
      const used = new Set();
      const mapping = {};

      names.forEach(name => {
        let val;
        do {
          val = Math.floor(Math.random() * 206) + 50; // 50-255
        } while (used.has(val));
        used.add(val);
        mapping[name] = val;
      });

      return mapping;
    }

    // ==================== สร้าง bytecode จาก instructions ====================
    function generateBytecode(instructions, opcodes) {
      const bytecode = [];
      const stringPool = [];
      const stringIndices = {};

      instructions.forEach(line => {
        line = line.trim();
        if (!line) return;

        // ใส่ junk instruction แบบสุ่ม
        if (Math.random() < 0.35) {
          bytecode.push(Math.floor(Math.random() * 256));
        }

        const parts = line.split(/\s+/);
        const cmd = parts[0].toLowerCase();

        if (cmd === 'push_int') {
          const num = parseInt(parts[1]);
          bytecode.push(opcodes['PUSH_INT']);
          bytecode.push(num & 0xFF);
          bytecode.push((num >> 8) & 0xFF);
        } 
        else if (cmd === 'push_str') {
          const str = parts.slice(1).join(' ').replace(/^["']|["']$/g, '');
          if (!(str in stringIndices)) {
            stringIndices[str] = stringPool.length;
            stringPool.push(str);
          }
          bytecode.push(opcodes['PUSH_STR']);
          bytecode.push(stringIndices[str]);
        } 
        else if (['add','sub','mul','print','pop','halt'].includes(cmd)) {
          const upper = cmd.toUpperCase();
          if (upper in opcodes) {
            bytecode.push(opcodes[upper]);
          }
        }
      });

      // จบด้วย HALT
      bytecode.push(opcodes['HALT']);
      return { bytecode, stringPool };
    }

    // ==================== Encrypt bytecode (XOR + junk) ====================
    const XOR_KEY = Math.floor(Math.random() * 91) + 30; // 30-120

    function encryptBytecode(bc) {
      const encrypted = [];
      bc.forEach(b => {
        encrypted.push(b ^ XOR_KEY);
        if (Math.random() < 0.25) {
          encrypted.push(Math.floor(Math.random() * 256)); // junk
        }
      });
      return encrypted;
    }

    // ==================== สร้าง Fake VM sections ====================
    function generateFakeVMs(count = 4) {
      const fakes = [];
      for (let i = 0; i < count; i++) {
        const size = Math.floor(Math.random() * 23) + 8;
        const section = Array(size).fill(0).map(() => Math.floor(Math.random() * 256));
        fakes.push(section);
      }
      return fakes;
    }

    // ==================== สร้างโค้ด Lua สุดท้าย ====================
    function generateLuaVM(opcodes, encrypted, fakes) {
      const opcodesStr = Object.entries(opcodes)
        .map(([k, v]) => `['${k}'] = ${v}`)
        .join(',\n    ');

      const fakeStr = fakes.map(arr => `{${arr.join(',')}}`).join(',\n    ');

      const bytecodeStr = `{${encrypted.join(',')}}`;

      return `-- VM Obfuscated Code
local KEY = ${XOR_KEY}
local OPCODES = {
    ${opcodesStr}
}

local function run(enc)
    local bc = {}
    for i = 1, #enc do
        bc[i] = bit32.bxor(enc[i], KEY)
    end
    
    local stack = {}
    local pc = 1
    
    while pc <= #bc do
        local op = bc[pc]; pc = pc + 1
        
        if op == OPCODES['PUSH_INT'] then
            local lo = bc[pc]; pc = pc + 1
            local hi = bc[pc]; pc = pc + 1
            table.insert(stack, lo + hi * 256)
        elseif op == OPCODES['PRINT'] then
            print(table.remove(stack))
        -- เพิ่ม handler อื่น ๆ ตามต้องการ
        elseif op == OPCODES['HALT'] then
            break
        end
        
        -- Anti-analysis: ข้ามสุ่ม
        if math.random() < 0.12 then
            pc = pc + math.random(1,4)
        end
    end
end

-- Fake sections เพื่อหลอก
local fakes = {
    ${fakeStr}
}

for _,f in ipairs(fakes) do
    local _ = f[math.random(1, #f)]
end

-- รันจริง
run(${bytecodeStr})
`;
    }

    // ==================== ฟังก์ชันหลัก ====================
    function obfuscate() {
      const input = document.getElementById('inputInstructions').value;
      const lines = input.split('\n').map(l => l.trim()).filter(Boolean);

      if (lines.length === 0) {
        alert("กรุณาใส่ instructions ก่อนนะครับ");
        return;
      }

      const opcodes = generateRandomOpcodes();
      const { bytecode, stringPool } = generateBytecode(lines, opcodes);
      const encrypted = encryptBytecode(bytecode);
      const fakes = generateFakeVMs();

      const result = generateLuaVM(opcodes, encrypted, fakes);

      document.getElementById('output').textContent = result;

      // แสดงข้อมูล debug เพิ่มเติม
      document.getElementById('debugInfo').textContent = 
        `XOR Key: ${XOR_KEY}\n` +
        `String Pool:\n\( {stringPool.map((s,i) => `[ \){i}] "${s}"`).join('\n')}`;
    }
  </script>
</body>
</html>
